using {{ rootnamespace }}.{{ applicationprojectname }}.Features.{{ modelnameplural }}.Caching;

namespace {{ namespacename }};
#nullable disable warnings

public class Delete{{ modelname }}Command:  ICacheInvalidatorRequest<Result<Guid>>
{
    public Guid[] Id {  get; }
    public string CacheKey => {{ modelname }}CacheKey.GetAllCacheKey;
    public CancellationTokenSource? SharedExpiryTokenSource => {{ modelname }}CacheKey.GetOrCreateTokenSource();
    public Delete{{ modelname }}Command(Guid[] id)
    {
    Id = id;
    }
}

public class Delete{{ modelname }}CommandHandler : 
                IRequestHandler<Delete{{ modelname }}Command, Result<Guid>>

{
    private readonly IApplicationDbContext _context;
    private readonly IMapper _mapper;
    private readonly IStringLocalizer<Delete{{ modelname }}CommandHandler> _localizer;
    public Delete{{ modelname }}CommandHandler(
        IApplicationDbContext context,
        IStringLocalizer<Delete{{ modelname }}CommandHandler> localizer,
            IMapper mapper
        )
    {
        _context = context;
        _localizer = localizer;
        _mapper = mapper;
    }
    public async Task<Result<Guid>> Handle(Delete{{ modelname }}Command request, CancellationToken cancellationToken)
    {
        var items = await _context.{{ modelnameplural }}.Where(x=>request.Id.Contains(x.Id)).ToListAsync(cancellationToken);
        foreach (var item in items)
        {
			// raise a delete domain event
			item.AddDomainEvent(new {{ modelname }}DeletedEvent(item));
            _context.{{ modelnameplural }}.Remove(item);
        }
        var result = await _context.SaveChangesAsync(cancellationToken);
        return await Result<Guid>.SuccessAsync(result);
    }

}

