using {{ rootnamespace }}.{{ applicationprojectname }}.Features.{{ modelnameplural }}.DTOs;
using {{ rootnamespace }}.{{ applicationprojectname }}.Features.{{ modelnameplural }}.Caching;

namespace {{ namespacename }};
#nullable disable warnings
    
public class Import{{ modelnameplural }}Command: ICacheInvalidatorRequest<Result<int>>
{
    public string FileName { get; set; }
    public byte[] Data { get; set; }
    public string CacheKey => {{ modelname }}CacheKey.GetAllCacheKey;
    public CancellationTokenSource? SharedExpiryTokenSource => {{ modelname }}CacheKey.GetOrCreateTokenSource();
    public Import{{ modelnameplural }}Command(string fileName,byte[] data)
    {
        FileName = fileName;
        Data = data;
    }
}
public record class Create{{ modelnameplural }}TemplateCommand : IRequest<Result<byte[]>>
{
 
}

public class Import{{ modelnameplural }}CommandHandler : 
                IRequestHandler<Create{{ modelnameplural }}TemplateCommand, Result<byte[]>>,
                IRequestHandler<Import{{ modelnameplural }}Command, Result<int>>
{
    private readonly IApplicationDbContext _context;
    private readonly IMapper _mapper;
    private readonly IStringLocalizer<Import{{ modelnameplural }}CommandHandler> _localizer;
    private readonly IExcelService _excelService;
    private readonly {{ modelname }}Dto _dto = new();

    public Import{{ modelnameplural }}CommandHandler(
        IApplicationDbContext context,
        IExcelService excelService,
        IStringLocalizer<Import{{ modelnameplural }}CommandHandler> localizer,
        IMapper mapper
        )
    {
        _context = context;
        _localizer = localizer;
        _excelService = excelService;
        _mapper = mapper;
    }
    #nullable disable warnings
    public async Task<Result<int>> Handle(Import{{ modelnameplural }}Command request, CancellationToken cancellationToken)
    {

        var result = await _excelService.ImportAsync(request.Data, mappers: new Dictionary<string, Func<DataRow, {{ modelname }}Dto, object?>>
        {
            {{ importfuncexpression }}
        }, _localizer[_dto.GetClassDescription()]);
        if (result.Succeeded && result.Data is not null)
        {
            foreach (var dto in result.Data)
            {
                var exists = await _context.{{ modelnameplural }}.AnyAsync(x => x.{{ masterproperty }} == dto.{{ masterproperty }}, cancellationToken);
                if (!exists)
                {
                    var item = _mapper.Map<{{ modelname }}>(dto);
                    // add create domain events if this entity implement the IHasDomainEvent interface
				    // item.AddDomainEvent(new {{ modelname }}CreatedEvent(item));
                    await _context.{{ modelnameplural }}.AddAsync(item, cancellationToken);
                }
                }
                await _context.SaveChangesAsync(cancellationToken);
                return await Result<int>.SuccessAsync(result.Data.Count());
        }
        else
        {
            return await Result<int>.FailureAsync(result.Errors);
        }
    }
    public async Task<Result<byte[]>> Handle(Create{{ modelnameplural }}TemplateCommand request, CancellationToken cancellationToken)
    {
        // TODO: Implement Import{{ modelnameplural }}CommandHandler method 
        var fields = new string[] {
                // TODO: Define the fields that should be generate in the template, for example:
                {{ templatefielddefinition }}
            };
        var result = await _excelService.CreateTemplateAsync(fields, _localizer[_dto.GetClassDescription()]);
        return await Result<byte[]>.SuccessAsync(result);
    }
}

